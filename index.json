
[{"content":"一些各种各样的 blog 与备忘\n","date":"2025 年 12 月 21 日","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"2025 年 12 月 21 日","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"$Liouville$ 定理和 $Liouville$ 方程不仅是统计力学的基础, 也是现代分子动力学 ($MD$) 算法设计的核心理论依据.\n相空间与系综\r#\r假定有包含 $N$ 个粒子的体系, 可以使用 $6N$ 个维度, 即 $3N$ 个广义坐标 $q$ 和 $3N$ 个共轭动量 $p$ 进行表示, 对应 $Hamilton$ 力学体系的表示方法. 这个 $6N$ 维的空间就称为 相空间.\n记状态 $\\Gamma(p,q)$ 表示相空间中的一个点, 自然这个系统的演化是由 $Hamilton$ 量 $H(p,q)$ 控制的. 所以有 $$\\begin{equation}\r\\dot q_i=\\frac{\\partial H}{\\partial p_i},\\quad\\dot p_i=-\\frac{\\partial H}{\\partial q_i}.\\label{Hami}\r\\end{equation}$$ 对于一个不显式依赖时间, 能量守恒的系统 (保守系统) 而言, $Hamilton$ 量就是能量. \\eqref{Hami} 决定着点在相空间中的运动, 轨道是永不自交的曲线, 不同的轨道也互不相交. 若是 $Hamilton$ 量守恒, 则这些轨迹曲线将始终保持在 $6N-1$ 维的超平面上. 如果系统能量不守恒, 而是处于 $E-\\Delta E $ 与 $E+\\Delta E$ 之间, 则轨迹也将会处于 $E-\\Delta E\\leq H(p,q)\\leq E+\\Delta E$ 之间.\n对于一个由大量粒子组成的体系, 且宏观上达到平衡, 对其物理性质 $A$ 的测定往往会持续一段时间 $\\delta t$ . 在 $\\delta t$ 的时间间隔中, 宏观而言其物理性质未发生变化, 但其相空间的状态已经发生显著变化. 可以认为, 对 $A$ 的测量是时间间隔 $\\delta t$ 的平均, 即 $$\r\\langle A \\rangle=\\frac{1}{\\delta t}\\int_{t}^{t+\\delta t}dtA(p(t),q(t)).\r$$ 一般为了数学方便, 会让 $\\delta t\\rightarrow\\infty$. 但即便如此, 也难以获取 $A(p(t),q(t))$ 的表达式. 所以引入了各态历经假设: 在足够长的时间内, 代表系统的点在系统的能量曲面上各个区域停留的时间相同.\n那么就可以换一种表述 $$\\begin{equation}\r\\langle A \\rangle=\\int dpdq \\rho(p,q,t)A(p,q).\\label{ens}\r\\end{equation}$$ \\eqref{ens} 被称为系综平均. 所以可以将 系综 定义为 大量具有相同宏观性质的系统的集合.\nLiouville 定理\r#\r$Liouville$ 定理可以表述为沿着 $Hamilton$ 系统的运动轨迹, 相空间密度保持不变, 即 $$\r\\frac{d\\rho(p,q,t)}{dt}=0.\r$$ 证明过程也很简单, 首先因为相空间中某系统的点不会凭空产生或消失, 所以 $$\\begin{equation}\r\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho v) = 0.\\label{liu}\r\\end{equation}$$ 其中:\n$v$ 是速度, 即广义坐标与广义动量随时间的变化率 $v=(\\dot{p},\\dot{q})$. $\\nabla$ 是散度算符 $\\nabla = (\\frac{\\partial}{\\partial q_i},\\frac{\\partial}{\\partial p_i})$. 散度 $\\nabla \\cdot (\\rho v)$ 表示流出的速度减去流入的速度. 展开\\eqref{liu} , 有 $$\r\\frac{\\partial \\rho}{\\partial t} + \\underbrace{\\sum_{i=1}^{3N} \\left( \\frac{\\partial \\rho}{\\partial q_i}\\dot{q}_i + \\frac{\\partial \\rho}{\\partial p_i}\\dot{p}_i \\right)}_{v \\cdot \\nabla \\rho} + \\rho \\underbrace{\\sum_{i=1}^{3N} \\left( \\frac{\\partial \\dot{q}_i}{\\partial q_i} + \\frac{\\partial \\dot{p}_i}{\\partial p_i} \\right)}_{\\nabla \\cdot v} = 0.\r$$ 对第三项代入 $Hamilton$ 方程, 有 $$\r\\nabla \\cdot v = \\sum_{i=1}^{3N} \\left( \\frac{\\partial}{\\partial q_i}\\left( \\frac{\\partial H}{\\partial p_i} \\right) + \\frac{\\partial}{\\partial p_i}\\left( - \\frac{\\partial H}{\\partial q_i} \\right) \\right).\r$$ 假定 $H$ 二次可微 $$\r\\frac{\\partial^2 H}{\\partial q_i \\partial p_i} = \\frac{\\partial^2 H}{\\partial p_i \\partial q_i}.\r$$ 所以 $$\r\\nabla \\cdot v = \\sum_{i=1}^{3N} \\left( \\frac{\\partial^2 H}{\\partial q_i \\partial p_i} - \\frac{\\partial^2 H}{\\partial p_i \\partial q_i} \\right) = 0.\r$$ 也就是说 $$\r\\frac{d\\rho}{d t}=\\frac{\\partial\\rho}{\\partial t}+v\\nabla\\rho=0.\r$$进一步考虑 $\\rho(p,q,t)$ 随时间的演化 $\\frac{\\partial\\rho}{\\partial t}=-v\\nabla\\rho$. 将 $Hamilton$ 方程代入 $$\r\\frac{\\partial \\rho}{\\partial t} = - \\sum_{i=1}^{3N} \\left( \\dot{{q}}_i \\frac{\\partial \\rho}{\\partial {q}_i} + \\dot{{p}}_i \\frac{\\partial \\rho}{\\partial {p}_i} \\right),\r$$ 有 $$\\begin{equation}\r\\frac{\\partial \\rho}{\\partial t} = - \\sum_{i=1}^{3N} \\left( \\frac{\\partial H}{\\partial {p}_i} \\frac{\\partial \\rho}{\\partial {q}_i} - \\frac{\\partial H}{\\partial {q}_i} \\frac{\\partial \\rho}{\\partial p_i} \\right) = -\\{\\rho, H\\}.\\label{liue}\\end{equation}\r$$ 称\\eqref{liue} 为 $Liouville$ 方程. 定义 $Liouville$ 算符 $$\riL = \\{\\cdot, H\\} = \\sum_{i} \\left( \\frac{\\partial H}{\\partial {p}_i} \\frac{\\partial}{\\partial {q}_i} - \\frac{\\partial H}{\\partial {q}_i} \\frac{\\partial}{\\partial {p}_i} \\right).\r$$ 于是 $Liouville$ 方程可以写为 $$\r\\frac{\\partial \\rho}{\\partial t} = -iL \\rho.\r$$\r解的形式\r#\r刘维尔方程是一个一阶线性微分方程, 其形式解是指数算符. 若 $H$ 不显式依赖时间, 则可以写为 $$\r\\rho(p,q, t) = e^{-iLt} \\rho(p,q, 0).\r$$ 定义 $U(t) = e^{-iLt}$ 为 传播子, 作用为使 $t=0$ 时刻的状态变为 $t$ 时刻的状态.\n","date":"2025 年 12 月 21 日","externalUrl":null,"permalink":"/posts/liouville_theorem/","section":"","summary":"","title":"Liouville定理","type":"posts"},{"content":"","date":"2025 年 12 月 21 日","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2025 年 12 月 21 日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025 年 12 月 21 日","externalUrl":null,"permalink":"/tags/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F/","section":"Tags","summary":"","title":"分子模拟","type":"tags"},{"content":"","date":"2025 年 12 月 21 日","externalUrl":null,"permalink":"/series/%E5%88%86%E5%AD%90%E6%A8%A1%E6%8B%9F%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/","section":"Series","summary":"","title":"分子模拟理论基础","type":"series"},{"content":"在约束动力学中, 某些任意选定的自由度 (如键长) 被约束固定, 而其他自由度则在分子间和分子内作用力的影响下自由演化. 约束动力学方法实际上利用了一组未定的乘子来表征沿键方向的作用力大小, 以维持键长恒定. 首先在不存在约束力的情况下求解一个时间步的运动方程, 用以确定这些约束力的大小并据此修正原子的位置.\n约束动力学最大优势在于简化复杂的多原子液体模拟, 只需额外添加基于分子几何结构的约束模块即可.\n这对于 柔性 分子而言是一个非常大的优化. 柔性, 也就是分子的键长和键角能够在一定程度上变化的分子. 与之相对的是 刚性, 也就是键长和键角都被固定的分子, 更进一步, 也就是分子内部没有任何相对运动.\n在推导之前, 先进行定义的描述.\n考虑一个包含 $N$ 个原子和 $K$ 个完整约束 (一般而言是键长) 的系统.\n$\\mathbf{r}(t) \\in \\mathbb{R}^{3N}$: 包含所有粒子坐标的向量, 有 $$\\mathbf{r} =\r\\begin{pmatrix}\rx_1 , y_1 , z_1 ,\rx_2 , y_2 , z_2 ,\r\\ldots ,\rx_N , y_N , z_N\r\\end{pmatrix}^T_{3N \\times 1}.$$ $\\mathbf{M} \\in \\mathbb{R}^{3N \\times 3N}$: 对角质量矩阵, 元素为 $m_i$.有 $$\\mathbf{M} = \\text{diag}(m_1, m_1, m_1, m_2, m_2, m_2, \\dots, m_N, m_N, m_N).$$ $g_k(\\mathbf{r},t) = |\\mathbf{r}_{i_k}(t) - \\mathbf{r}_{j_k}(t)|^2 - d_k^2 = 0$: 第 $k$ 个约束方程, 其中 $d_k$ 是键长. 需要注意的是, $\\mathbf{r}_{i_k}(t)-\\mathbf{r}_{j_k}(t)$ 的下标表示第 $k$ 组相对位置, 即第 $k$ 组 $\\mathbf{r}_{i}(t) - \\mathbf{r}_{j}(t)$. $\\mathbf{B}(t) \\in \\mathbb{R}^{K \\times 3N}$ 为坐标相对于约束的梯度, 即 $$\\mathbf{B}_{ki}(t) = \\frac{\\partial g_k(t)}{\\partial r_i(t)},$$ 其中 $B_k$ 表示键的方向向量, 但大小包含因子 $2|\\mathbf{r}_{ij}|$. 对于 $SHAKE$ 算法, 只需确保每个位置约束 $$g_k(\\mathbf{r},t) = |\\mathbf{r}_{i_k}(t) - \\mathbf{r}_{j_k}(t)|^2 - d_k^2 = 0$$ 满足即可, 对于 $RATTLE$ 算法, 则还需满足速度约束 $$\\dot g_k(t)=\\mathbf{r}(t) \\cdot \\mathbf{v}(t) = 0.$$\rSHAKE 算法\r#\r以 $Leap-Frog$ 算法为例.\n假设系统遵循牛顿力学方程, 在蛙跳算法中, 我们不仅要更新位置, 还要保证更新后的位置 $\\mathbf{r}(t+\\Delta t)$ 精确满足约束 $g_k[\\mathbf{r}(t+\\Delta t)] = 0$.\n首先忽略约束力 $g$, 能得到未受约束力的下一步位置 $$\r\\mathbf{r}^{unc}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}^{unc}(t+\\frac{1}{2}\\Delta t) \\Delta t,\r$$ 其中 $$\r\\mathbf{v}^{unc}(t+\\frac{1}{2}\\Delta t) = \\mathbf{v}(t-\\frac{1}{2}\\Delta t) + \\Delta t \\mathbf{M}^{-1} \\mathbf{F}(t).\r$$ 接下来引入位置修正力, 引入 $Lagrange$ 乘子向量 $\\lambda$ 以体现每个约束下力的大小, 所以约束力可以写为 $\\mathbf{B}^T \\boldsymbol{\\lambda}$, 有 $$\r\\mathbf{r}(t+\\Delta t) = \\mathbf{r}^{unc}(t+\\Delta t) + {\\Delta t}\\mathbf{M}^{-1} \\mathbf{B}^T(t) \\boldsymbol{\\lambda}.\r$$ 所以可以相当简单地将约束表示为 $$\rg_k[\\mathbf{r}^{unc}(t+\\Delta t) - \\mathbf{M}^{-1} \\mathbf{B}^T(t) \\Delta t\\boldsymbol{\\lambda}] = 0, \\quad \\forall k.\r$$\rRATTLE 算法\r#\r以速度 $Verlet$ 算法为例.\n对约束条件 $|\\mathbf{r}_{i_k}(t) + \\mathbf{r}_{j_k}(t)|^2 - d_k^2 = 0$ 求导可以得到速度约束条件 $\\dot g_k(t)=\\mathbf{r}(t) \\cdot \\mathbf{v}(t) = 0$, 等价于 $\\mathbf{B}(t) \\cdot \\mathbf{v}(t) = 0$.\n$SHAKE$ 仅修正位置, 导致速度实际上不满足约束导数 (即 $\\mathbf{r}(t) \\cdot \\mathbf{v}(t) \\neq 0$). $RATTLE$ 基于速度 $Verlet$ 算法, 能够同时实现位置与速度的更新.\n首先更新无约束的半步速度与一步位置, 有 $$\\begin{align*}\r\\mathbf{v}^{unc}(t+\\frac{1}{2}\\Delta t) \u0026= \\mathbf{v}(t) + \\frac{\\Delta t}{2} \\mathbf{M}^{-1} \\mathbf{F}(t),\\\\\r\\mathbf{r}^{unc}(t) \u0026= \\mathbf{r}(t) + \\Delta t \\mathbf{v}^{unc}(t+\\frac{1}{2}\\Delta t).\r\\end{align*}$$ 相同地, 引入 $Lagrange$ 乘子向量 $\\lambda_R$ 使得约束条件 $g_k$ 成立, 有 $$\r\\mathbf{r}(t+\\Delta t) = \\mathbf{r}^{unc}(t+\\Delta t) + {\\Delta t}\\mathbf{M}^{-1} \\mathbf{B}^T(t) \\boldsymbol{\\lambda}_R.\r$$ 进一步, 也是 $RATTLE$ 算法的精髓, 就是同时更新一步速度 $\\mathbf{v}(t+\\Delta t)$, 使其满足速度约束条件 $\\dot g_k(t+\\Delta t)=\\mathbf{r}(t+\\Delta t) \\cdot \\mathbf{v}(t+\\Delta t) = 0$. 首先使用速度 $verlet$ 算法获取无约束一步速度 $$\r\\mathbf{v}^{unc}(t+\\Delta t) = \\mathbf{v}(t+\\frac{1}{2}\\Delta t) + \\frac{\\Delta t}{2} \\mathbf{M}^{-1} \\mathbf{F}(t+\\Delta t).\r$$ 然后引入速度乘子 $\\mu$, 有 $$\r\\mathbf{v}(t+\\Delta t) = \\mathbf{v}^{unc}(t+\\Delta t) + \\mathbf{M}^{-1} \\mathbf{B}^T(t+\\Delta t) \\boldsymbol{\\mu}.\r$$ 由 $\\mathbf{B}(t+\\Delta t) \\cdot \\mathbf{v}(t+\\Delta t) = 0$ 得 $$\r\\mathbf{B}(t+\\Delta t) \\left[ \\mathbf{v}^{unc}(t+\\Delta t) + \\mathbf{M}^{-1} \\mathbf{B}^T(t+\\Delta t) \\boldsymbol{\\mu} \\right] = 0.\r$$ 整理, 得 $$\r\\mathbf{B}(t+\\Delta t) \\mathbf{M}^{-1} \\mathbf{B}^T(t+\\Delta t) \\boldsymbol{\\mu} = - \\mathbf{B}(t+\\Delta t) \\mathbf{v}^{unc}(t+\\Delta t).\r$$\r键角约束\r#\r对于键角, 处理方法也并不困难, 由三角形的性质可以知道, 三角形的三边长固定, 则三个内角角度也可以知道. 以 $H_2O$ 分子为例, 仅需再添加一个 $r_{13}$ 和 $v_{13}$ 项即可约束键角.\n求解\r#\r对于位置约束 $\\boldsymbol{\\lambda}$ 与 $\\boldsymbol{\\lambda_R}$, 二者求解方式基本一致, 以 $\\boldsymbol{\\lambda}$ 为例, 令 $\\boldsymbol{\\gamma} = \\Delta t^2 \\boldsymbol{\\lambda}$ 以简化计算, 则有 $$\rg_k[\\mathbf{r}^{unc}(t+\\Delta t) - \\mathbf{M}^{-1} \\mathbf{B}^T(t) \\boldsymbol{\\gamma}] = 0, \\quad \\forall k.\r$$ 这是一个关于 $\\boldsymbol{\\gamma}$ 的非线性方程组. 使用迭代法求解.\n对第 $k$ 个约束方程在 $\\mathbf{r}^{unc}(t+\\Delta t)$ 处进行泰勒展开并保留一阶项 $$\rg_k(\\mathbf{r}(t+\\Delta t)) \\approx g_k(\\mathbf{r}^{unc}(t+\\Delta t)) + \\nabla g_k(\\mathbf{r}^{unc}(t+\\Delta t)) \\cdot \\delta (\\mathbf{r}) = 0,\r$$ 其中 $\\delta (\\mathbf{r}) = \\mathbf{r}(t+\\Delta t)-\\mathbf{r}= \\mathbf{M}^{-1} \\mathbf{B}^T(T) \\boldsymbol{\\gamma}$, 并近似认为一步之内键的方向变化不大, 即 $\\nabla g_k(\\mathbf{r}^{unc}(t+\\Delta t))=\\mathbf{B}_k^T(t)$, 此时得到一个线性方程组\n$$g_k(\\mathbf{r}^{unc}(t+\\Delta t)) + \\sum_{j=1}^K \\left[ \\nabla g_k(\\mathbf{r}^{unc}(t+\\Delta t)) \\cdot \\mathbf{M}^{-1} \\nabla g_j^T(\\mathbf{r}^{unc}(t+\\Delta t)) \\right] \\gamma_j = 0.$$ 化简, 将 $g_k(\\mathbf{r}^{unc}(t+\\Delta t))$ 组合到一起, 写成矩阵形式, 即为 $$\r(\\mathbf{B}(t) \\mathbf{M}^{-1} \\mathbf{B}^T(t)) \\boldsymbol{\\gamma} = - g(\\mathbf{r}^{unc}(t+\\Delta t)).\r$$ 针对上面这个矩阵, 可以用迭代法求解, 具体步骤为\n首先计算所有约束的破坏程度 $g_k(\\mathbf{r})$. 对于每一个约束 $k$，假设其他约束不变，计算修正量 $\\gamma_k$ $$\\gamma_k = \\frac{d_k^2 - |\\mathbf{r}_{ij}^{unc}|^2}{2 \\mathbf{r}_{ij, n} \\cdot \\mathbf{M}_{ij}^{-1} \\cdot \\mathbf{r}_{ij, unc}}.$$ 使用修正量 $\\gamma_k$ 更新两个原子的位置 $\\mathbf{r}_{i}, \\mathbf{r}_{j}$. 重复上述三步, 直到所有约束误差 $|\\sigma_k| \u003c \\text{tolerance}$. 速度约束 $\\lambda^{(v)}$ 是个一次线性方程组. 但对于 $RATTLE$ 的速度约束, 其存在耦合对角项, 即存在非对角元素非零的情况. 原因很简单, 对于水 $H_1-O-H_2$ 而言, 假设要修正 $O-H_1$ 的键长, 因为要移动中心的 $O$ 原子, 势必也会影响到 $O-H_2$ 的键长. 所以一样采用上述迭代法求解.\n能使用迭代法的原因\r#\r要求矩阵 $\\mathbf{B}\\mathbf{M}^{-1}\\mathbf{B}^T$ 对角占优, 即 $$\r|A_{kk}| \u003e \\sum_{j \\neq k} |A_{kj}|.\r$$ 其中对角项 $A_{kk}$ 大致正比于 $\\frac{1}{m_A} + \\frac{1}{m_B}$ (键两端原子的质量倒数和), 非对角项 $A_{kj}$ 大致正比于 $\\frac{\\cos \\theta}{m_{shared}}$ (共享原子的质量倒数乘以键角余弦).\n所以只要 键角 $\\theta$ 不要接近 0° 或 180°, 且共享原子的质量不是无穷小, 对角项通常远大于非对角项.\n特殊情况\r#\r但是这些算法对于一些特殊的分子不管用, 如线性分子 $CS_2$ 和平面分子苯 $C_6H_6$.\n首先引入 自由度 概念. 对于每一个分子, 有三个平动自由度, 即在 $x,y,z$ 三个方向上进行平动, 也有三个转动自由度, 即绕 $x,y,z$ 三个轴进行转动.\n对于 $CS_2$ 分子, 其有三个平动自由度, 但只能绕两个轴旋转, 不能绕自身所在的直线旋转. 因为在经典力学和统计力学中这种沿着键轴的自转不构成一个有效的自由度(无法储存动能, 也不改变分子的空间构型). 所以 $CS_2$ 有 $5$ 个自由度. 而三个原子完全独立运动有 $3\\times 3=9$ 个坐标, 故需要 $9-5=4$ 个方程来施加约束.\n但只能提供 $3$ 个约束, 即两个键的键长和键角, 不够 $4$ 个来让其变成刚体.\n对于苯而言, 其作为刚体有 $6$ 个自由度, 需要的约束有 $6\\times 3-6=12$ 个 (6个原子组成六边形), 当然可以设法通过固定对角线, 固定各原子的距离找到这样 $12$ 个约束条件, 但将其写成矩阵, 会惊讶地发现这个矩阵的行列式为 $0$, 所有的约束都在一个平面内, 没有任何约束能防止原子 \u0026ldquo;跑出平面\u0026rdquo;. 数学上表现为方程组线性相关, 无法求逆.\n针对这种问题, 有两种方案.\n一是选取一组足以确定分子几何结构的原子子集, 对这些原子施加约束条件, 并将其余原子的坐标表示为以主要 \u0026ldquo;核心\u0026rdquo; 原子坐标为系数的线性组合.\n二是使用一些替代算法. 如 $SETTLE$ 和 $LINCS$ 等. 对于小分子, 可以使用 $SETTLE$ 算法, 也就是直接代数求解.\n对于线性和环状分子, 可以使用 $LINCS$ 算法. 其利用最小作用原理重写受约束的运动方程, 通过对接不受约束的位置施加矩阵校正, 从而将沿 \u0026ldquo;旧\u0026rdquo; 键方向投影的键长调整至正确值. 若再加入针对键旋转的校正, 这一方法无需迭代即可达到相当高的精度, 并据称其计算速度比 $SHAKE$ 快数倍, 同时在大时间步长下也表现出更优异的收敛特性.\n对于完全刚性的分子, 基于四元数参数或旋转矩阵的辛积分算法似乎是最简单的方法. 一旦在分子模型中引入任何非刚性的要素, 约束动力学就成了一个有吸引力的选择.\n对于柔性分子而言, 共识是约束键长, 但让键角和扭转角依据势能进行演化.\n这是出于程序效率的考量. 对于刚性的三角型分子单元, $RATTLE/SHAKE$ 算法的迭代收敛异常缓慢, 这通常迫使我们减小时间步长. 那这还不如不去管这个约束. 此外, 键长的振动频率很高, 将其约束为定值不会产生较大影响, 但键角变化会较为显著且变化评率较低, 将其约束会破坏构象变化, 得不偿失.\nLINCS 算法\r#\r$LINCS$ (Linear Constraint Solver) 由 Hess 等人在 1997 年提出. 与传统的 $SHAKE/RATTLE$ 算法不同, $LINCS$ 不依赖迭代求解, 而是基于矩阵级数展开的线性投影方法.\n对于 $LINCS$ 而言其约束条件定义与 $SHAKE$ 和 $RATTLE$ 略有不同.\n定义约束条件 $g'_k(\\mathbf{r},t) = |\\mathbf{r}_{i_k}(t) - \\mathbf{r}_{j_k}(t)| - d_k = 0$, $\\mathbf{B}_{ki}(t) = \\frac{\\partial g'_k(t)}{\\partial r_i(t)}$.\n此处 $\\mathbf{B}_{ki}(t)$ 就是键 $k$ 的方向向量.\n首先 $LINCS$ 是通过投影来解 $g'(t+\\Delta t)=0$ 的. 将新的键长投影到键的方向上, 并假设从 $t$ 时刻的位置到 $t+\\Delta t$ 时刻的位置旋转角变化不大, 有 $$B(t) \\cdot (\\mathbf{r}(t+\\Delta t) - \\mathbf{r}^{unc}(t+\\Delta t)) = \\mathbf{d} - \\mathbf{l}_{unc},$$ 其中 $\\mathbf{d}$ 是键长列向量, $\\mathbf{l}_{unc}$ 表示每个约束条件中的原子在时刻 $t+\\Delta t$ 未施加约束时的距离即 $|\\mathbf{r}_{i}(t+\\Delta t)-\\mathbf{r}_{j}(t+\\Delta t)|$ 组成的列向量.\n此时代入 $Leap-Frog$ 的位置更新公式, 有 $$\r\\mathbf{B}(t) (\\mathbf{M}^{-1} \\mathbf{B}^T(t) \\boldsymbol{\\lambda}') = \\mathbf{d} - \\mathbf{l}_{unc}.\r$$ 令 $\\mathbf{A}=\\mathbf{B}(t) \\mathbf{M}^{-1} \\mathbf{B}^T(t)$ 表示连接某一相同原子的键 $k$ 和键 $j$ 的加权点积. 并定义 $\\mathbf{D}$ 为$\\mathbf{A}$ 的对角元素组成的矩阵. 将 $\\mathbf{A}$ 分解为 $$\r\\mathbf{A} = \\mathbf{D}^{1/2} (\\mathbf{I} - \\mathbf{S}) \\mathbf{D}^{1/2},\r$$ 其中 $I$ 为单位矩阵. 由此得到耦合矩阵 $S$ 定义 $$\r\\mathbf{S} = \\mathbf{I} - \\mathbf{D}^{-1/2} \\mathbf{A} \\mathbf{D}^{-1/2}.\r$$ 对于耦合矩阵 $S$, 其表示耦合强度. $S_{kj} = - \\frac{A_{kj}}{\\sqrt{A_{kk} A_{jj}}}$ 且 $S_{kk}=0$, 所以有 $$\rS_{kj} \\propto \\frac{\\mathbf{b}_k \\cdot \\mathbf{b}_j}{m_{shared}} = \\frac{|\\mathbf{b}_k| |\\mathbf{b}_j| \\cos \\theta_{kj}}{m_{shared}}.\r$$ 所以可以对 $\\mathbf{A}\\cdot\\boldsymbol{\\lambda}'=\\mathbf{d} - \\mathbf{l}_{unc}$ 施加变换 $$\r\\mathbf{A}\\mathbf{D}^{1/2}\\mathbf{D}^{-1/2}\\cdot\\boldsymbol{\\lambda}'=\\mathbf{d} - \\mathbf{l}_{unc},\r$$ $$\r\\mathbf{D}^{-1/2}\\mathbf{A}\\mathbf{D}^{-1/2}\\mathbf{D}^{1/2}\\cdot\\boldsymbol{\\lambda}'=\\mathbf{D}^{-1/2}(\\mathbf{d} - \\mathbf{l}_{unc}),\r$$ $$\r\\mathbf{D}^{-1/2}\\mathbf{D}^{1/2} (\\mathbf{I} - \\mathbf{S}) \\mathbf{D}^{1/2}\\mathbf{D}^{-1/2}\\mathbf{D}^{1/2}\\cdot\\boldsymbol{\\lambda}'=\\mathbf{D}^{-1/2}(\\mathbf{d} - \\mathbf{l}_{unc}),\r$$ $$\r(\\mathbf{I} - \\mathbf{S})\\cdot\\boldsymbol{\\lambda}''=\\mathbf{D}^{-1/2}(\\mathbf{d} - \\mathbf{l}_{unc}).\r$$ 其中 $\\boldsymbol{\\lambda}''=\\mathbf{D}^{1/2}\\cdot\\boldsymbol{\\lambda}'$, 施加变换的目的是为了得到 $Neumann$ 级数的标准形式, 从而使用其进行求解. 根据 $Neumann$ 级数 $$\r(\\mathbf{I} - \\mathbf{S})^{-1} = \\mathbf{I} + \\mathbf{S} + \\mathbf{S}^2 + \\mathbf{S}^3 + \\dots + \\mathbf{S}^n,\r$$ 可以将 $\\boldsymbol{\\lambda}''$ 表示为 $$\r\\boldsymbol{\\lambda}''= (\\mathbf{I} +\\sum_1^L \\mathbf{S}^i)\\mathbf{D}^{-1/2}(\\mathbf{d} - \\mathbf{l}_{unc}).\r$$ 将上式解得 $\\boldsymbol{\\lambda}''$ 可以逆向推得 $\\boldsymbol{\\lambda}'$, 再通过 $$\r\\mathbf{r}_{proj}(t+\\Delta t) = \\mathbf{r}_{unc}(t+\\Delta t) + \\mathbf{M}^{-1} \\mathbf{B}^T(t) \\boldsymbol{\\lambda}'\r$$ 获得 $\\mathbf{r}_{proj}(t+\\Delta t)$.\n因为在计算时存在一个近似 $B(t+\\Delta t)=B(t)$, 所以如此得到位置 $\\mathbf{r}_{proj}(t+\\Delta t)$ 所推算得到的键长可能会比实际上的键长略长, 据此可以得到新的键长列向量 $\\mathbf{l}_{corr}$. 再需要引入修正 $d_{corr,k} = \\sqrt{2d_k^2 - l_k^2}$, 获得误差向量 $\\mathbf{d}_{corr}-\\mathbf{l}_{corr}$ 取一个新的修正 $\\boldsymbol{\\lambda}_{corr}$, 复用方程 $$\r\\mathbf{A}\\cdot\\boldsymbol{\\lambda}_{corr}=\\mathbf{d}_{corr}-\\mathbf{l}_{corr}.\r$$ 用一样的方法求解后得到 $\\boldsymbol{\\lambda}_{corr}$, 使用 $$\r\\mathbf{r}(t+\\Delta t) = \\mathbf{r}_{proj}(t+\\Delta t) + \\mathbf{M}^{-1} \\mathbf{B}^T(t+\\Delta t) \\boldsymbol{\\lambda}_{corr}(t)\r$$ 即可得到最终的下一步坐标 $\\mathbf{r}(t+\\Delta t)$.\n总结\r#\r首先明确一下 $SHAKE$ 算法 和 $RATTLE$ 算法的区别.\n$SHAKE$ 算法针对的是经典的 $Verlet$ 算法或基于其优化而来的 $Leap-Frog$ 算法, 只显式更新位置, 通过位置来推出速度. 所以 $SHAKE$ 只修正位置.\n而 $RATTLE$ 算法既显式更新位置, 又显式更新速度. 所以 $RATTLE$ 既修正位置, 又修正速度.\n类比一下开车. $SHAKE$ 相当于在导航时将车的位置拉回路中间, 而 $RATTLE$ 则相当于既把车头拉回路中间, 又将方向盘摆正.\n其次在软件使用方面, 对于 $GROMACS$ 一般默认采用 $LINCS$ 算法, 且 $GROMACS$ 常用 $Leap-Frog$ 积分器, 所以使用的是 $SHAKE$, 除非强制开启速度 $verlet$ 算法.\n而对于 $LAMMPS$, 设定使用 $verlet$ 算法时, 哪怕使用 fix shake 命令, 其在运行中也会使用 $RATTLE$ 来进行速度修正.\n最后针对实际应用, 一般而言仅需考虑键长约束, 而使键角根据势能进行演化.\n","date":"2025 年 12 月 18 日","externalUrl":null,"permalink":"/posts/constraint_dynamics/","section":"","summary":"","title":"约束动力学","type":"posts"},{"content":"简单来说, $verlet$ 算法的作用是求解牛顿运动方程 $F=ma$:根据当前时刻原子们的位置和受力, 算出它们下一时刻会在哪里.\n原始 verlet 算法\r#\r原始 $verlet$ 算法基于泰勒展开. 对于一个粒子在 $t$ 时刻的位置 $r(t)$, 对其向前向后各按照 $\\Delta t$ 进行展开, 即 $$\\begin{align}\rr(t+\\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2}a(t)\\Delta t^2 + \\frac{1}{6}b(t)\\Delta t^3 + \\dots\\label{t+deltat},\\\\\rr(t-\\Delta t) = r(t) - v(t)\\Delta t + \\frac{1}{2}a(t)\\Delta t^2 - \\frac{1}{6}b(t)\\Delta t^3 + \\dots\\label{t-deltat}.\r\\end{align}$$ 将 \\eqref{t+deltat} 与 \\eqref{t-deltat} 两式相加, 有 $$\\begin{equation}\rr(t+\\Delta t)+r(t-\\Delta t)=2r(t)+a(t)\\Delta t^2+O(\\Delta t^4).\\label{verlet-1}\r\\end{equation}$$ 式 \\eqref{verlet-1} 即为 $verlet$积分公式. 即根据前一时刻的位置与当前时刻的位置与受力能得到下一时刻的位置. 使用 $O(\\Delta t^4)$ 进行近似的原因很简单, 位置 $r(t)$ 的高阶导数难以计算, 因此简单的 $Euler$ 法 $$r(t + \\Delta t) = r(t) + v(t) \\Delta t + O(\\Delta t^2)$$ 只能计算到 $v(t)(\\Delta t)$, 局部误差为 $O(\\Delta t^2)$，全局误差是 $O(\\Delta t)$.\n而 $verlet$ 算法因为消去了 $b(t)(\\Delta t^3)$ 项, 能够仅使用二阶导数 $a(t)(\\Delta t^2)$ 将局部误差减小到 $O(\\Delta t^4)$, 全局误差缩小到 $O(\\Delta t^3)$.\n然而在 $MD$ 中需要粒子的速度来体现动能 $K$ 从而计算温度 $T$.\n如果只使用原始 $verlet$ 算法, 即将 \\eqref{t+deltat} 与 \\eqref{t-deltat} 两式相减来计算速度 $$\rv(t) = \\frac{r(t+\\Delta t) - r(t-\\Delta t)}{2\\Delta t}+O(\\Delta t^2).\r$$ 这个公式的误差是 $O(\\Delta t^2)$. 这意味着即使位置算得很准, 速度也是\u0026quot;估算\u0026quot;出来的. 这不仅精度差 (误差 $\\Delta t^2$), 而且必须要算出下一步位置后, 才能回头算出现在的速度.\n速度 verlet 算法\r#\r为了解决速度的问题，Swope 等人在 1982 年整理出了$ Velocity Verlet$ 形式. 它数学上和原始 $Verlet$ 等价, 但同时显式地计算位置和速度.\n首先根据 $t$ 时刻的力计算出加速度 $a$, 推断出 $t + \\frac{1}{2}\\Delta t$ 的速度 $$\rv(t + \\frac{1}{2}\\Delta t) = v(t) + \\frac{1}{2}a(t)\\Delta t.\r$$ 再利用 $t + \\frac{1}{2}\\Delta t$ 时刻的速度计算出 $t + \\Delta t$ 时刻的位置 $$r(t + \\Delta t) = r(t) + v(t + \\frac{1}{2}\\Delta t)\\Delta t.$$ 在 $t + \\Delta t$ 时刻的位置 $r(t + \\Delta t)$ 计算新的力与加速度 $a(t+\\Delta t)$ 并利用新的加速度计算 $t + \\Delta t$ 的速度 $$v(t + \\Delta t) = v(t + \\frac{1}{2}\\Delta t) + \\frac{1}{2}a(t + \\Delta t)\\Delta t.$$可能会惊讶, 速度 $verlet$ 算法似乎与经典 $verlet$ 算法没什么区别, 但前者精度比后者高.\n在计算机运算中, 对于经典 $verlet$ 算法, 当 $\\Delta t$ 很小时, $r(t)$ 和 $r(t-\\Delta t)$ 是两个非常接近的极大数值. 两个很大的数相减, 导致有效数字大量丢失.\n而对于速度 $verlet$ 算法而言, 其位置公式是 $r_{new}=r_{old}+\\text{小量}$ 这种形式避免了两个大数相减, 能够保留更多的有效数字.\n蛙跳算法\r#\r蛙跳算法的思路与速度 $verlet$ 算法十分类似, 除了每半步存储速度, 每一步存储位置以外基本一样.\n更新速度采用 $$\rv(t + \\frac{1}{2}\\Delta t) = v(t - \\frac{1}{2}\\Delta t) + \\Delta t.\r$$ 更新位置采用 $$r(t + \\Delta t) = r(t) + v(t + \\frac{1}{2}\\Delta t)\\Delta t.$$ 与速度 $verlet$ 算法同样, 蛙跳算法也不会产生大数相减导致的精度损失.\nverlet 算法理论基础\r#\rTrotter 分解\r#\r假设有两个数字 $a$ 和 $b$, 显然有: $$e^{a+b} = e^a \\cdot e^b.$$ 这对于普通数字是成立的. 但是, 在量子力学或统计力学中, 我们要处理的是算符或矩阵, 如 $A$ 和 $B$. 如果 $A$ 和 $B$ 不对易 ($AB \\neq BA$)，那么： $$e^{A+B} \\neq e^A e^B.$$ Trotter 发现, 虽然 $e^{A+B} \\neq e^A e^B$, 但如果指数上面的 $\\Delta t$ 非常小, 可以有一个高精度的近似: $$e^{(A+B)\\Delta t} \\approx e^{B \\frac{\\Delta t}{2}} e^{A \\Delta t} e^{B \\frac{\\Delta t}{2}} + O(\\Delta t^3).$$ 这就是 $Trotter$ 分解. 它把一个复杂的\u0026quot;混合指数\u0026quot; $e^{A+B}$ 拆成了两个简单的\u0026quot;独立指数\u0026quot;的乘积.\n移位算符\r#\r系统的随时间演化由 $Liouville$ 算符 $iL$ 控制, 即 $$f(t+\\Delta t) = e^{iL \\Delta t} f(t).$$ 这里 $iL$ 包含了位置的变化 ($\\frac{\\partial}{\\partial q}$) 和速度的变化 ($\\frac{\\partial}{\\partial p}$).\n因为位置和速度耦合在一起, 直接求解 $e^{iL \\Delta t}$ 较为困难. 所以在速度 $verlet$ 算法中本质是将演化算符使用 $Trotter$ 分解把算符近似为两个半步速度 $iL_2$ 和一个一步位置 $iL_1$ $$e^{iL\\Delta t} \\approx e^{\\frac{iL_2 \\Delta t}{2}} e^{iL_1 \\Delta t} e^{\\frac{iL_2 \\Delta t}{2}}.$$ 其中 $iL_1$ 只体现动量对位置的影响, $iL_2$ 只体现受力对动量的影响.\n那么为什么分解之后就能计算了呢? 数学上有个性质叫 \u0026ldquo;移位算符\u0026rdquo;, 即指数形式的微分算符作用在函数上等价于直接把变量平移 $c$, 也就是 $$e^{c \\frac{\\partial}{\\partial x}} f(x) = f(x+c).$$证明也比较简单. 对算符 $A$ 而言, 其指数函数并不是寻常意义的指数函数, 而是泰勒展开的一系列算符. $$\re^A = \\sum_{n=0}^{\\infty} \\frac{1}{n!} A^n = 1 + A + \\frac{1}{2!}A^2 + \\frac{1}{3!}A^3 + \\dots + \\frac{1}{i!}A^i.\r$$ 令 $A = c \\frac{d}{dx}$, 代入上式, 有 $$\re^{c \\frac{d}{dx}} = \\sum_{n=0}^{\\infty} \\frac{1}{n!} \\left( c \\frac{d}{dx} \\right)^n = \\sum_{n=0}^{\\infty} \\frac{c^n}{n!} \\frac{d^n}{dx^n}\r$$ 此时让指数算符作用于 $f(x)$, 有 $$\\begin{aligned}\r\\left( e^{c \\frac{d}{dx}} \\right) f(x) \u0026= \\left( \\sum_{n=0}^{\\infty} \\frac{c^n}{n!} \\frac{d^n}{dx^n} \\right) f(x) \\\\\r\u0026= \\sum_{n=0}^{\\infty} \\frac{c^n}{n!} \\frac{d^n f(x)}{dx^n} \\\\\r\u0026= f(x) + c f'(x) + \\frac{c^2}{2!} f''(x) + \\frac{c^3}{3!} f'''(x) + \\dots+ \\frac{c^i}{i!} f^{(i)}(x).\r\\end{aligned}$$ 恰好就是 $f(x+c)$ 的泰勒展开.\n影子 $Hamilton$ 量\r#\r以这种方式拆分 $Liouville$ 算符, 能够保留一个很关键的性质 (辛性质): 尽管轨迹只是近似的, 无法精确守恒真实能量 $H$, 但却能严格守恒一个 \u0026ldquo;影子$Hamilton$量\u0026rdquo; $\\tilde{H}$. 其可以写成 $$\\tilde{H} = H + (\\Delta t)^2 H_2 + (\\Delta t)^4 H_4 + \\dots$$ 其中 $H$ 是真实能量, $H_2, H_4$ 是与系统导数有关的修正项.\n这样就带来了一个优势:\n$\\tilde{H}$ 是守恒的: 对于 Verlet 算法, 虽然真实能量 $H$ 不守恒, 但影子能量 $\\tilde{H}$ 是严格的常数 (在机器精度范围内). 且因为 $\\Delta t$ 很小, $\\tilde{H}$ 和 $H$ 相当接近 $$|H(t) - \\tilde{H}| \\approx O(\\Delta t^2).$$ 换句话说, 系统将在相空间中的一条超曲面上运动, 而这条超曲面与真实的等能超曲面 \u0026ldquo;接近\u0026rdquo;. 所以 既然 $\\tilde{H}$ 不变, 那么真实的能量 $H$ 就只能在 $\\tilde{H}$ 附近小幅度震荡, 而永远不会发生大的偏差.\n至于辛 (Symplectic) 性质, 我的评价是跟鲁棒性一个水准的翻译.\n简单而言, 辛性质就是 \u0026ldquo;保相体积\u0026rdquo; 的性质, 也就是相空间中的某一超平面上不再添加或减少点, 对应着 $Liouville$ 定理.\n在相空间中, 辛性质的体现就是使统计力学的平均值计算成为可能且可信的.\n此外需要指出的是, 逻辑链条是: 分解保留了辛性质 $\\rightarrow$ 辛性质保证了影子哈密顿量的存在 $\\rightarrow$ 影子哈密顿量守恒.\n即, 如果一个离散映射是辛的 (保相体积) , 那么在数学上, 它一定可以被看作是某个连续哈密顿系统 ($\\tilde{H}$) 的精确演化结果.\n","date":"2025 年 12 月 16 日","externalUrl":null,"permalink":"/posts/verlet-algorithm/","section":"","summary":"","title":"verlet算法","type":"posts"},{"content":"拉格朗日力学 ($Lagrangian\\text{ } Mechanics$) 的构建是继牛顿力学之后经典力学的一个飞跃. 传统的牛顿力学使用的是力与矢量进行分析, 而拉格朗日力学使用能量与几何对运动进行分析.\n拉格朗日量的定义为 $$\r\\begin{equation}\rL = T - V = L(q,\\dot{q},t).\\label{lag}\r\\end{equation}\r$$式 \\eqref{lag} 中 $L$ 为拉格朗日量($Lagrangian$), $T$ 为动能, $V$ 为势能. $q$ 为广义坐标, $\\dot{q}=\\frac{dq}{dt}$ 为广义速度, $t$ 为时间. 广义坐标, 广义速度的定义下文会进行讨论.\n在进行推导之前, 最重要的一点是放弃使用牛顿力学的思维, 如针对保守系统, 系统总能量 $E$ 是守恒量. 而拉格朗日量 $L$ 则不是一个守恒量. 举个简单的例子, 向上垂直以一定速度抛出一个小球, 假设小球仅受重力影响, 抛出时势能恰好为 $0$. 在抛出时总能量 $E=T+V$, 拉格朗日量 $L=T-V$, 此时二者都为一个正数, 而到最高点, 总能量 $E$ 还是一个正数, 而此时 $L$ 是一个负数.\n举这个例子是想说明两点, 第一是拉格朗日量并非是一个守恒量, 第二是拉格朗日量是一个过程量, 会随着时间剧烈变化.\n广义量与最小作用原理\r#\r记 $q$ 为广义坐标. 与广义坐标相对的是狭义坐标也就是牛顿力学中常用的坐标, 量纲一般为米 (m). 广义坐标无量纲, 可以是笛卡尔坐标, 可以是极坐标, 也可以是能表示坐标的其他东西.\n记$\\dot{q}=\\frac{dq}{dt}$ 为 广义速度 , 仅仅定义为广义坐标对时间的导数, 无其他含义.\n此外还有 广义动量 $p$, 在牛顿力学中狭义动量定义为 $p=m\\cdot v$, 广义动量则没有一个确切的表达方式, 仅仅是一个在拉格朗日量中与广义坐标 $q$ 的共轭量, 即 $p=\\frac{\\partial L}{\\partial \\dot q}$.\n产生广义量的原因是为了统一形式. 如牛顿力学在直角坐标系下十分好用, 但换到球坐标系, 柱坐标系下其表达形式就会产生一些复杂的项. 使用广义量能够在拉格朗日体系下确保形式的统一.\n\u0026ldquo;广义\u0026quot;的本质, 就是把物理定律从具体的坐标系几何形状中解放出来, 变成一种纯粹的代数关系.\n作用量 $S$ 定义为拉格朗日量 $L$ 对时间的积分 $$\r\\begin{equation}\rS=\\int L(q,\\dot{q},t)dt.\\label{action}\r\\end{equation}\r$$回到最小作用原理, 哈密顿原理指出: 真实的运动路径是使 \u0026ldquo;作用量 ($S$) \u0026quot; 取极值 (通常是最小值) 的那条路径.\n也就意味着 $\\delta S=0$.\n泛函\r#\r泛函也就是作用于函数的函数. 可以敏锐地察觉到式 \\eqref{action} 中的广义坐标 $q$ 是一个依赖时间的函数 $q(t)$, 所以根据定义 $S$ 就是一个泛函.\n如果时间不是连续的, 而是离散的, 比如电脑里的模拟. 此时可以将时间切分成 $n$ 个点, 即$t=t_1, t_2, \\ldots, t_n,$ 此时广义坐标变化形成的路径也不会是一个连续的曲线而是一系列离散的点 $q(t)=\\{q(t_1), q(t_2), \\ldots, q(t_n)\\}$. 此时作用量 $S$ 就会是一个 $n$ 个变量的多元函数 $$\rS(q_1, q_2, \\dots, q_n) = \\sum L(q_i, \\frac{q_{i+1}-q_i}{\\Delta t}) \\Delta t.\r$$ 此时如果 $\\Delta t$ 相当小, 上式可以写为 $$\r\\frac{\\partial S}{\\partial q_i} = 0 \\quad (\\text{对于每一个 } i).\r$$而如果时间是连续的, 那么 $n$ 就会变得无穷大, 此时变量就会变得无穷多, $\\partial$ 符号就会显得很乏力. 此时引入符号 $\\delta$ .\n回顾普通微积分, 找函数的极值有两种方法, 一是导数为 $0$, 即$f'(x) = 0$ 或 $\\frac{df}{dx} = 0$, 二是微分为 $0$, 即 $df$ 是 $dx$ 的高阶无穷小, $df = f'(x) dx = 0$.\n符号 $\\delta$ 对应的是方法二, $\\delta S$ 表示随着路径 $q(t)$ 变化了 $\\delta q(t)$ 时作用量 $S$ 的变化量.\n欧拉-拉格朗日 (Euler-Lagrange) 方程\r#\r当然光有定义式是无法解决问题的. 顺着最小作用原理, 可以使用 变分法 继续往下推导.\n需要指出的是, 此处提到的变分法与另一篇 blog 中提到的量子化学中的变分法略有区别, 此处的变分法是泛函变分法, 让泛函对路径形状的一阶变分为 0, 得到的结果是一个微分方程, 而量子化学中的变分法是线性变分法, 让能量对系数的偏导数为 0, 要得到的是一个用于拟合的代数方程组.\n首先对于轨迹 $q(t)$ 引入一个微小扰动 $\\delta q(t)$, 但保证起点与终点与原轨迹保持不变, 即 $\\delta q(t_0)=\\delta q(t_1)=0$.\n接下来使作用量 $S$ 确定为极值, 此时 $\\delta S$ 对应于 $\\delta q(t)$ 也应为 $0$. 即 $$\r\\delta S = \\delta \\int_{t_0}^{t_1} L(q, \\dot{q}, t) \\, dt = \\int_{t_0}^{t_1} \\delta L \\, dt = 0.\r$$ 使用全微分表示 $\\delta L$, 有 $$\r\\delta L = \\frac{\\partial L}{\\partial q}\\delta q + \\frac{\\partial L}{\\partial \\dot q}\\delta\\dot q = \\frac{\\partial L}{\\partial q}\\delta q + \\frac{\\partial L}{\\partial \\dot q}\\frac{d}{dt}\\delta q.\r$$ 此时 $$\r\\begin{equation}\r\\delta S =\\int_{t_0}^{t_1}(\\frac{\\partial L}{\\partial q}\\delta q + \\frac{\\partial L}{\\partial \\dot q}\\frac{d}{dt}\\delta q)dt=\\int_{t_0}^{t_1}(\\frac{\\partial L}{\\partial q}\\delta q)dt + \\int_{t_0}^{t_1}(\\frac{\\partial L}{\\partial \\dot q}\\frac{d}{dt}\\delta q)dt=0.\\label{3}\r\\end{equation}\r$$ 对于第二项, 使用分部积分法. $$\r\\begin{equation}\r\\int_{t_0}^{t_1}\\frac{\\partial L}{\\partial \\dot q}\\frac{d}{dt}\\delta q dt=\\left[\\frac{\\partial L}{\\partial \\dot q}\\delta q\\right]_{t_0}^{t_1}-\\int_{t_0}^{t_1}\\delta q \\frac{d}{dt}\\frac{\\partial L}{\\partial \\dot q}dt=0.\\label{4}\r\\end{equation}\r$$ 因为 $\\delta q(t_0)=\\delta q(t_1)=0$ 所以式 \\eqref{4} 第一项为 $0$. 将式 \\eqref{4} 结果代回式 \\eqref{3}, 有 $$\r\\int_{t_0}^{t_1}(\\frac{\\partial L}{\\partial q}\\delta q -\\delta q \\frac{d}{dt}\\frac{\\partial L}{\\partial \\dot q})dt=\\int_{t_0}^{t_1}(\\frac{\\partial L}{\\partial q}-\\frac{d}{dt}\\frac{\\partial L}{\\partial \\dot q})\\delta qdt=0\r$$ 因为 $\\delta q(t)$ 是在两点之间任意选取的微小偏差, 要让这个积分对于任意 $\\delta q$ 恒为 0, 唯一的办法就是中括号里的被积函数恒等于 0, 即 $$\\begin{equation}\r\\frac{\\partial L}{\\partial q}-\\frac{d}{dt}\\frac{\\partial L}{\\partial \\dot q}=0.\\label{res}\r\\end{equation}$$ 式 \\eqref{res} 被称为欧拉-拉格朗日 (Euler-Lagrange) 方程.\n勒让德变换与哈密顿量\r#\r勒让德变换 ($Legendre\\text{ }Transformation$) 在数学上是从一组独立变量到另一组独立变量的变换.\n可以通过这种方式, 让描述系统的变量 $\\dot q$ 转换为 $p$. 这样可以在解欧拉-拉格朗日方程时将一个二阶偏微分方程降为两个对称的一阶偏微分方程.\n对拉格朗日量 $L$ 求全微分 $$\\begin{equation}\rdL = \\frac{\\partial L}{\\partial q}dq + \\frac{\\partial L}{\\partial \\dot q}d\\dot q + \\frac{\\partial L}{\\partial t}dt=\\frac{\\partial L}{\\partial q}dq + d(\\frac{\\partial L}{\\partial \\dot q}\\dot q) -\\dot q d\\frac{\\partial L}{\\partial \\dot q} + \\frac{\\partial L}{\\partial t}dt.\\label{6}\r\\end{equation}$$ 将广义动量 $p=\\frac{\\partial L}{\\partial \\dot q}$ 与欧拉-拉格朗日方程 \\eqref{res} 代入式 \\eqref{6}, 且有 $$\\begin{equation}\\begin{aligned}\rdL =\u0026 \\frac{d}{dt}\\frac{\\partial L}{\\partial \\dot q}dq + d(p\\dot q) -\\dot q dp + \\frac{\\partial L}{\\partial t}dt = \\dot p dq + d(p\\dot q) -\\dot q dp + \\frac{\\partial L}{\\partial t}dt\\\\\r=\u0026\\frac{d}{dt}(pdq-qdp)+ d(p\\dot q)+ \\frac{\\partial L}{\\partial t}dt.\r\\end{aligned}\\label{7}\\end{equation}$$ 对于式 \\eqref{7} , 右侧已经只依赖于 $q$, $p$ 和 $t$ 三个变量. 出于数学习惯 (也恰好符合物理形式) 将式\\eqref{7} 写为 $$\r\\begin{equation}\rd(p\\dot q) - dL = \\dot qdp - \\dot pdq - \\frac{\\partial L}{\\partial t}dt.\\label{8}\r\\end{equation}\r$$ 定义哈密顿量 ($Hamiltonian$) $$\rH(p,q,t) = p\\dot{q} - L(q,\\dot q,t).\r$$ 将其全微分 $$\r\\begin{equation}\rdH(p,q,t)=\\frac{\\partial H}{\\partial p}dp+\\frac{\\partial H}{\\partial q}dq+\\frac{\\partial H}{\\partial t}dt\\label{9}\r\\end{equation}\r$$ 将式 \\eqref{8} 和式 \\eqref{9} 对照, 得到 $$\\begin{align}\r\\dot q\u0026=\\frac{\\partial H}{\\partial p}\\label{10},\\\\\r\\dot p\u0026=-\\frac{\\partial H}{\\partial q}\\label{11}.\r\\end{align}$$ 式 \\eqref{10} 和式 \\eqref{11} 即为哈密顿正则方程 ($Hamilton's\\text{ }Canonical\\text{ }Equations$).\n","date":"2025 年 12 月 15 日","externalUrl":null,"permalink":"/posts/lagrangian-mechanics/","section":"","summary":"","title":"拉格朗日量与哈密顿量","type":"posts"},{"content":"由于 WSL2 的网络架构默认是 NAT 模式 (相当于它躲在 Windows 主机的后面，拥有自己独立的虚拟 IP)，因此其他电脑无法直接“看到”它.\n所以最方便也是最简单的方法是, 使用端口转发访问.\n在 WSL2 中配置并启动 SSH 服务\r#\r在 WSL 的终端中输入\n1 2 sudo apt update sudo apt install openssh-server 以安装服务端的 SSH 服务.\n按照需要可以修改 /etc/ssh/sshd_config 文件中的内容.\n修改后输入\n1 2 sudo service ssh restart hostname -I 重启 SSH 服务, 并查看 WSL 的 IP 地址.\n在 Windows 系统上设置端口转发\r#\r因为外部电脑只能看到你的 Windows IP, 我们需要告诉 Windows:\u0026quot; 把所有发给你 2222 端口的请求，都转交给 WSL2 的 22 端口\u0026quot;.\n在管理员模式的 PowerShell 中输入\n1 netsh interface portproxy add v4tov4 listenport=2222 listenaddress=0.0.0.0 connectport=22 connectaddress=x.x.x.x 我们将 Windows 的 2222 端口转发到 WSL2 的 22 端口. 避免占用 Windows 默认的 22 端口, 防止冲突.\n其中 x.x.x.x 是在 WSL 的 IP 地址.\n配置 Windows 防火墙\r#\rWindows 防火墙默认会拦截外部对 2222 端口的访问, 需要手动放行. 继续在管理员模式的 PowerShell 中输入\n1 New-NetFirewallRule -Name \u0026#34;WSL2_SSH\u0026#34; -DisplayName \u0026#34;WSL2 SSH Access\u0026#34; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 2222 即可开放 2222 端口.\n这样就可以通过 SSH remote 通过 2222 端口访问 windows 的 IP 地址从而访问 WSL 了.\n不过因为 WSL 的特性, 其 IP 地址每次 WSL 重启或者 Windows 重启都会变. 所以可以使用一个 PowerShell 脚本, 每次重启都运行一下, 即可自动更新端口转发的规则.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #wsl_setting.ps1 # 获取 WSL2 的当前 IP $wsl_ip = (wsl hostname -I).Trim() if ($wsl_ip -eq \u0026#34;\u0026#34;) { Write-Host \u0026#34;WSL 没在运行，请先打开 WSL。\u0026#34; exit } # 删除旧的转发规则 (防止堆积) netsh interface portproxy delete v4tov4 listenport=2222 listenaddress=0.0.0.0 # 添加新的转发规则 netsh interface portproxy add v4tov4 listenport=2222 listenaddress=0.0.0.0 connectport=22 connectaddress=$wsl_ip # 启动 SSH 服务 (需要在 WSL 里配置了免密 sudo，或者可以手动去 WSL 输入 service ssh start) wsl -u root service ssh start Write-Host \u0026#34;转发规则已更新: Windows 2222 -\u0026gt; WSL $wsl_ip : 22\u0026#34; 使用 Ed25519 秘钥对配置公钥私钥访问\r#\rEd25519 是基于椭圆曲线密码学的一种算法, 在 2011 年左右被提出. 它的设计目标就是在保证安全性的同时, 提供更好的性能.\n具体可以查看深入解析：SSH 密钥从 RSA 到 Ed25519这一篇博客.\n假定已经安装好 SSH 客户端. 在客户端的PowerShell或者 CMD 中运行\n1 ssh-keygen -t ed25519 -C \u0026#34;你的注释\u0026#34; 以生成 Ed25519 密钥对. -C 参数是备注, 方便辨认.\n然后一路回车下去, 生成的秘钥保存在 C:\\Users\\USERNAME\\.ssh\\ 目录中. 其中 id_ed25519 是私钥, id_ed25519.pub 是公钥.\n接下来手动将刚生成的 id_ed25519.pub 中的内容复制到 WSL 的 ~/.ssh/authorized_keys 文件中即可.\n最后, 用 vim 或者其他方法配置 /etc/ssh/sshd_config 文件.需要保证\n1 2 PasswordAuthentication no PubkeyAuthentication yes 第一句话表明禁止通过密码访问, 第二句话表明允许通过秘钥访问. 这样就能彻底封死暴力破解的可能. 最后使用\n1 sudo service ssh restart 重启 SSH 服务即可.\n","date":"2025 年 11 月 30 日","externalUrl":null,"permalink":"/posts/remote_ssh_to_wsl/","section":"","summary":"","title":"使用remote SSH远程访问另一台电脑上的WSL2虚拟机","type":"posts"},{"content":"","date":"2025 年 11 月 30 日","externalUrl":null,"permalink":"/tags/%E6%9D%82%E9%A1%B9/","section":"Tags","summary":"","title":"杂项","type":"tags"},{"content":"","date":"2025 年 11 月 19 日","externalUrl":null,"permalink":"/tags/%E9%87%8F%E5%AD%90%E5%8C%96%E5%AD%A6/","section":"Tags","summary":"","title":"量子化学","type":"tags"},{"content":"为了处理包含相互作用粒子的体系 (例如原子或分子) 的与不含时$Schr\\ddot odinger$ 方程, 必须采用近似方法. 变分法的意义在于能够通过测量体系有限的波函数, 对体系整体的能量与状态进行估计.\n变分理论\r#\r设一个系统的不含时 $Hamilton$ 算符 $\\hat{H}$ , 其最低能量本征值为 $E_1$. 若 $\\phi$ 是系统粒子坐标的一个归一化且性质良好的波函数, 并满足该系统的边界条件, 则\n\\begin{equation} \\int \\phi^{*} \\hat{H} \\phi d\\tau \\geq E_1.\\label{1-1} \\end{equation}\n即变分定理能够帮助我们计算基态能量的下限.\n变分定理的证明较为简单, 我们通过将波函数 $\\phi$ 使用 $Hamilton$ 算符 $\\hat{H}$ 的完备正交本征函数 $\\psi_i$ 进行展开, 即\n\\begin{equation} \\phi=\\sum_i a_i \\times \\psi_i,\\label{1-2} \\end{equation}\n满足 $\\hat{H} \\psi_i = E_i \\times \\psi_i$. 将 \\eqref{1-2} 式带入 \\eqref{1-1} 式, 假设 (实际上也确实符合数学要求) 求和符号可以跟随系数 $a_i$ 和 $a_j$ 挪到积分符号外, 得\n$$ \\int \\phi^{*} \\hat{H} \\phi d\\tau = \\int\\sum_i a_i^{*} \\psi_i^{*} \\hat{H} \\sum_j a_j \\psi_j d\\tau = \\sum_i \\sum_j a_i^{*} a_j\\int \\psi_i^{*} \\hat{H} \\psi_j d\\tau. $$进一步, 应用本征函数的性质, 得:\n$$ \\sum_i \\sum_j a_i^{*} a_j\\int \\psi_i^{*} \\hat{H} \\psi_j d\\tau = \\sum_i \\sum_j a_i^{*} a_j\\int \\psi_i^{*} E_j \\psi_j d\\tau = \\sum_i \\sum_j a_i^{*} a_j E_j \\int \\psi_i^{*} \\psi_j d\\tau. $$因为所选择的本征函数彼此正交, 有 $\\int \\psi_i^{\\*} \\psi_j d\\tau = \\delta_{ij}$, 且系数 $a_i, a_j$ 都为实数, 有 \\begin{equation} \\sum_i \\sum_j a_i^{*} a_j E_j \\int \\psi_i^{*} \\psi_j d\\tau = \\sum_i \\sum_j a_i^{*} a_j E_j \\delta_{ij} = \\sum_j |a_j|^2 E_j.\\label{1-3} \\end{equation}\n因为波函数 $\\phi$ 是归一化的, 根据归一化条件 $\\int \\phi^*\\phi d\\tau=1$, 有\n\\begin{equation} \\int \\phi^* \\phi , d\\tau = \\sum_i \\sum_j a_i^* a_j \\int \\psi_i^* \\psi_j , d\\tau = \\sum_i \\sum_j a_i^* a_j \\delta_{ij} = \\sum_j |a_j|^2 = 1.\\label{1-4} \\end{equation}\n将式 \\eqref{1-3}, \\eqref{1-4} 代回式 \\eqref{1-1}, 有\n$$ \\int \\phi^{*} \\hat{H} \\phi d\\tau = \\sum_j a_j^2 E_j \\geq E_1. $$如果移除波函数 $\\phi$ 已经归一化这个假设条件, 可以给 $\\phi$ 乘一个归一化系数 $k$ 使其归一化, 即$\\int k^* \\phi^* k\\phi d\\tau = 1$. 此时有 $\\int \\phi^*\\phi d\\tau = \\frac{1}{|k|^2}$, 式 \\eqref{1-1} 则变为\n$$ \\frac{\\int \\phi^{*} \\hat{H} \\phi d\\tau}{\\int \\phi^*\\phi d\\tau}\\geq {E_1}. $$为了得到基态能量的良好近似值, 我们会尝试许多不同的 $\\phi$, 并寻找能使变分积分取到最低值的那个函数. 根据式 \\eqref{1-1}, 变分积分的值越低, 我们所得到的近似就越精确.\n在实际运用中, 人们通常会将未知参数 $a_i$ 放入已知的函数 $\\psi$ 中以构建未知波函数 $\\phi$, 然后通过调整这些参数来使变分积分达到最小值.\n#对变分函数进行展开 上一部分中, 通过变分定理得到了基态状态能量以及基态波函数. 此时我们考虑激发态, 将激发态能量从低到高依次排列\n$$ E_1\\leq E_2\\leq \\ldots . $$对于归一化的波函数, 变分函数为\n$$ \\int \\phi^{*} \\hat{H} \\phi d\\tau = \\sum_i a_i^2 E_i , \\int \\phi^{*} \\phi d\\tau = \\sum_i a_i^2 = 1. $$考虑第一激发态, 能量为$E_2$. 如果想类似上文一样应用变分函数得到下界, 则需要使基态能量消失, 即 $a_1 = 0$. 而什么时候 $a_1 = 0$ 成立呢? 通过上文的推导过程可以得知 $\\langle \\psi_1|\\phi \\rangle = 0$, 即 $\\int \\psi_1^* \\phi d\\tau = 0$ 时, $a_1 = 0 $ 成立. 推导过程省略, 重复上文步骤即可验证. 此时\n以此类推, $\\langle \\psi_1|\\phi \\rangle = 0$, 且 $\\langle \\psi_2|\\phi \\rangle = 0 $ 时, 有 $\\int \\phi^{*} \\hat{H} \\phi d\\tau\\geq E_2.$\n当 $\\langle \\psi_1|\\phi \\rangle = 0, \\langle \\psi_2|\\phi \\rangle = 0 , \\langle \\psi_3|\\phi \\rangle = 0$ 时, 有 $\\int \\phi^{*} \\hat{H} \\phi d\\tau\\geq E_4$ 等.\n线性变分函数与久期方程\r#\r在分子研究中广泛使用的一种特殊变分函数是线性变分函数, 目标函数, 即线性所求波函数的本征函数是由 $n$ 个已知的线性无关函数 $f_i$ 的线性组合构成的.\n$$ \\phi = \\sum_i^n c_i f_i $$可以注意到此时线性变分函数使用的基函数 $f_i$ 已经无需是波函数 $\\phi$ 的本征函数了, 但依然需要满足边界条件. 额外假设 $f_i$ 是实函数, $c_i$ 是实数. 此时进行与变分定理类似的推导\n$$ \\int \\phi^{*} \\hat{H} \\phi d\\tau = \\int \\sum_i^n c_i^* f_i^* \\hat{H} \\sum_j^n c_j f_j d\\tau = \\sum_i^n \\sum_j^n c_i^* c_j \\int f_i^* \\hat{H} f_j d\\tau. $$$$ \\int \\phi^{*} \\phi d\\tau = \\int \\sum_i^n c_i^* f_i^* \\sum_j^n c_j f_j d\\tau = \\sum_i^n \\sum_j^n c_i^* c_j \\int f_i^* f_j d\\tau. $$记 $\\int f_i^* \\hat{H} f_j d\\tau$ 为 $H_{ij}$, $\\int f_i^* f_j d\\tau$为 $S_{ij}$.\n记 $W$为\n$$ W=\\frac{\\int \\phi^{*} \\hat{H} \\phi d\\tau}{\\int \\phi^{*} \\phi d\\tau}=\\frac{\\sum_i^n \\sum_j^n c_i^* c_j H_{ij}}{\\sum_i^n \\sum_j^n c_i^* c_j S_{ij}}. $$此时有\n\\begin{equation} W\\times \\sum_i^n \\sum_j^n c_i^* c_j S_{ij} = \\sum_i^n \\sum_j^n c_i^* c_j H_{ij}. \\label{2-1} \\end{equation}\n$W$ 作为 $c_1, c_2, \\ldots ,c_n$ 的函数, 可以通过使 $W$ 对各个系数的一阶偏导为 $0$ 求得最小值(与此同时 $W\\geq E_1$ ), 即\n$$ \\frac{\\partial W}{\\partial c_k} = 0,\\qquad k = 1, 2, \\ldots, n. $$对式 \\eqref{2-1} 两边对 $c_i$ 求偏导\n$$ \\frac{\\partial W}{\\partial c_k}\\sum_i^n\\sum_j^n c_i^* c_j S_{ij} + W \\frac{\\partial }{\\partial c_k}\\sum_i^n\\sum_j^n c_i^* c_j S_{ij} = \\frac{\\partial }{\\partial c_k}\\sum_i^n\\sum_j^n c_i^* c_j H_{ij}, \\quad k = 1, 2,\\ldots,n. $$偏导符号可以移动到求和符号内部, 且因为 $c_i$ 均为实数, 有 $c_i^*=c_i$, 且因为要求最小值, $\\frac{\\partial W}{\\partial c_k} = 0$ 自动成立\n$$ W \\sum_i^n\\sum_j^n \\frac{\\partial }{\\partial c_k} c_i c_j S_{ij} = \\sum_i^n\\sum_j^n \\frac{\\partial }{\\partial c_k} c_i c_j H_{ij}, \\quad k = 1, 2,\\ldots,n. $$此时对于求和内部的 $\\frac{\\partial }{\\partial c_k} c_i c_j$, 只有当 $k = i$ 或 $k = j$ 时才能有值, 而当 $k=i=j$ 时被记两遍, 所以系数为 $2$ 有\n$$ 2W \\sum_i^n c_i S_{ki} = 2\\sum_i^n c_i H_{ki}, \\quad k = 1, 2,\\ldots,n. $$移一下项\n$$ \\sum_i^n c_i (H_{ki} - W\\times S_{ki}) = 0, \\quad k = 1, 2,\\ldots,n. $$此时变成 $n$ 个方程组成的 $n$ 维其次线性方程组如下\n$$ \\begin{align*} c_1 (H_{11} - W\\times S_{11}) + c_2(H_{12} - W\\times S_{12}) + \\ldots + c_2(H_{1n} - W\\times S_{1n}) \u0026= 0\\\\ c_1 (H_{21} - W\\times S_{21}) + c_2(H_{22} - W\\times S_{22}) + \\ldots + c_2(H_{2n} - W\\times S_{2n}) \u0026= 0\\\\ ...................................................................\u0026.....\\\\ c_1 (H_{n1} - W\\times S_{n1}) + c_2(H_{n2} - W\\times S_{n2}) + \\ldots + c_2(H_{nn} - W\\times S_{nn}) \u0026= 0 \\end{align*} $$这个线性方程组可以被写成矩阵形式 $$ \\begin{equation} \\left( \\begin{matrix} H_{11} - W\\times S_{11} \u0026 H_{12} - W\\times S_{12} \u0026 \\cdots \u0026 H_{1n} - W\\times S_{1n}\\\\ H_{21} - W\\times S_{21} \u0026 H_{22} - W\\times S_{22} \u0026 \\cdots \u0026 H_{2n} - W\\times S_{2n}\\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots\\\\ H_{n1} - W\\times S_{n1} \u0026 H_{n2} - W\\times S_{n2} \u0026 \\cdots \u0026 H_{nn} - W\\times S_{nn} \\end{matrix} \\right)\\times \\left( \\begin{matrix} c_1\\\\ c_2\\\\ \\vdots\\\\ c_n \\end{matrix} \\right)= \\left( \\begin{matrix} 0\\\\ 0\\\\ \\vdots\\\\ 0 \\end{matrix} \\right).\\label{2-2} \\end{equation} $$ 因为这是 $n$ 个方程组成的 $n$ 维其次线性方程组, 其有非零解的条件是系数行列式 $det(H_{ij} - W\\times S_{ij})$ 为零, 即\n$$ \\begin{equation} \\left| \\begin{matrix} H_{11} - W S_{11} \u0026 H_{12} - W S_{12} \u0026 \\cdots \u0026 H_{1n} - W S_{1n} \\\\ H_{21} - W S_{21} \u0026 H_{22} - W S_{22} \u0026 \\cdots \u0026 H_{2n} - W S_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ H_{n1} - W S_{n1} \u0026 H_{n2} - W S_{n2} \u0026 \\cdots \u0026 H_{nn} - W S_{nn} \\end{matrix} \\right| = 0. \\label{2-3} \\end{equation} $$式 \\eqref{2-3} 被称为 久期方程. 由代数知识可知, 这个行列式是一个关于 $W$ 的 $n$ 次方程, 可以解得 $n$ 个 $W$. 将其从小到大排列\n$$ W_1\\leq W_2\\leq W_3\\leq \\ldots \\leq W_n. $$式 \\eqref{2-2} 可以解出当 $W$ 最小时的 $c_1, c_2,\\ldots, c_n$. 根据 $c_1, c_2,\\ldots, c_n$ 可以组合出 基态和 $n-1$ 个激发态的能量, 将其从小到大排列\n$$ E_1\\leq E_2\\leq E_3\\leq \\ldots \\leq E_n. $$已经有证明 [J. K. L. MacDonald, Phys. Rev., 43, 830 (1933); R. H. Young, Int. J. Quantum Chem., 6, 596 (1972)],\n$$ E_1\\leq W_1,\\quad E_2\\leq W_2,\\quad E_3\\leq W_3,\\quad \\ldots,\\quad E_n\\leq W_n. $$如果这些函数构成一个完备集, 那么我们就能得到该系统的真正波函数. 然而, 通常我们需要无穷多个函数才能形成一个完备集.\n为了得到基态波函数的近似值, 我们取久期方程的最小根 $W_1$, 并将其代入方程 \\eqref{2-2} 中. 然后求解方程, 能够得到一组系数 $c_1^1, c_2^1,\\ldots, c_n^1$. 上标 $i$ 表示这组系数是通过带入 $W_i$ 确定的. 然而因为式 \\eqref{2-3} 表明行列式的值为 $0$, 可以确定有方程没有发挥作用, 所以无法得到这一组数据的精确值, 只能得到其比率. 幸运的是, 我们还有一个归一化条件可以使用. 这样就可以得到 $\\phi_1=\\sum_i^n c_i f_i$ 作为一个近似的基态波函数, 类似地用索引更高的根 $W_i$ 可以计算出激发态的波函数. 可以证明这 $n$ 个近似基态波函数是相互正交的.\n","date":"2025 年 11 月 19 日","externalUrl":null,"permalink":"/posts/variation_method_and_secular_equation/","section":"","summary":"","title":"量子化学中变分法与久期方程的推导","type":"posts"},{"content":"量子化学计算中使用较为广泛的近似方法除了之前提到过的变分法, 还有一个方法是微扰法. 假设某系统的不含时 $Hamilton$ 算符为 $\\hat H$ 且我们无法准确求解 $Schr\\ddot odinger$ 方程 $\\hat H \\psi_n = E_n \\psi_n$. 假设算符 $\\hat H$ 由另一算符 $\\hat H^{0} $ 通过某一微小扰动 $\\hat H'$ 得到, 即 $\\hat H = \\hat H^{0}+\\hat H'$. 其中 $\\hat H^{0}\\psi^{0}_n=E_n^{0}\\psi^{0}_n$, 且此 $Schr\\ddot odinger$ 方程可求解.\n此时我们的任务是设法将 $\\hat H$ 与 $\\hat H^0$ 关联起来. 引入一个实数 $\\lambda \\in [0, 1]$, 用以使 $\\hat H^0$ 逐渐接近 $\\hat H$ .自然有\n$$\r\\hat H = \\hat H^0+\\lambda\\hat H',\r$$当 $\\lambda=0$ 时, 表示 $\\hat H^0$, 当 $\\lambda=1$ 时则表示 $\\hat H$.\n简并与非简并能级的微扰处理方式有所不同.\n非简并能级的微扰理论\r#\r对于 $Schr\\ddot odinger$ 方程\n$$\r\\begin{equation}\r\\hat H \\psi_n = (\\hat H^0+\\lambda\\hat H')\\psi_n = E_n \\psi_n,\\label{1-1}\r\\end{equation}\r$$除了坐标, 波函数 $\\psi_n$ 同时也是参数 $\\lambda\\in [0,1]$ 的函数, 即 $\\psi_n=\\psi_n(q,\\lambda)$, 其中参数 $q$ 表示坐标. 同理体系能量 $E_n=E_n(\\lambda)$. 能量无关坐标 $q$, 因为相对于包含坐标的函数 $\\psi_n$ 而言能量是一个常数.\n能量 $E_n=E_n(\\lambda)$ 和 波函数 $\\psi_n=\\psi_n(q,\\lambda)$ 分别对参数 $\\lambda$ 使用 $Taylor$ 展开\n$$\r\\psi_n=\\psi_n|_{\\lambda=0}+\\lambda \\frac{\\partial \\psi_n}{\\partial \\lambda}|_{\\lambda=0}+\\frac{\\lambda^2}{2!} \\frac{\\partial^2 \\psi_n}{\\partial \\lambda^2}|_{\\lambda=0}+\\ldots+\\frac{\\lambda^k}{k!} \\frac{\\partial^k \\psi_n}{\\partial \\lambda^k}|_{\\lambda=0},\r$$$$\rE_n=E_n|_{\\lambda=0}+\\lambda \\frac{d E_n}{d \\lambda}|_{\\lambda=0}+\\frac{\\lambda^2}{2!} \\frac{d^2 \\psi_n}{d \\lambda^2}|_{\\lambda=0}+\\ldots+\\frac{\\lambda^k}{k!} \\frac{d^k \\psi_n}{d \\lambda^k}|_{\\lambda=0}\r$$显然当 $\\lambda\\rightarrow0$ 时, $\\psi_n | _{\\lambda=0}=\\psi_n^{(0)} $, $E _n| _{\\lambda=0}=E_n^{(0)}$. 记\n$$\r\\psi_n^{(k)}\\equiv\\frac{1}{k!} \\frac{\\partial^k \\psi_n}{\\partial \\lambda^k}|_{\\lambda=0}, E_n^{(k)}\\equiv\\frac{1}{k!} \\frac{d^k \\psi_n}{d \\lambda^k}|_{\\lambda=0}.\r$$此时 $\\psi_n$ 和 $E_n$ 可以表示为\n$$\r\\begin{equation}\r\\psi_n=\\psi_n^{(0)}+\\lambda\\psi_n^{(1)}+\\lambda^2\\psi_n^{(2)}+\\ldots+\\lambda^k\\psi_n^{(k)},\\label{1-2}\r\\end{equation}\r$$$$\r\\begin{equation}\rE_n=E_n^{(0)}+\\lambda E_n^{(1)}+\\lambda^2 E_n^{(2)}+\\ldots+\\lambda^k E_n^{(k)}.\\label{1-3}\r\\end{equation}\r$$称 $\\psi_n^{(k)}$ 和 $E_n^{(k)}$ 为对 $\\psi_n$ 和 $E_n$ 的 k 阶修正. 对于上述级数我们希望其在 $\\lambda=1$ 处收敛, 但通常而言无法满足这一条件. 但哪怕这些级数发散, 应用修正后也可以有一个不错的近似效果.\n对于微扰法, 一般使用 $\\langle \\psi_n^{(0)}|\\psi_n^{(0)}\\rangle=1$ 与 $\\langle \\psi_n^{(0)}|\\psi_n\\rangle=1$ 作为归一化条件, 称为 间接归一化. 如果 $\\psi_n$ 不满足归一化条件, 可以乘一个系数 $1/\\langle \\psi_n^{(0)}|\\psi_n\\rangle$ 使其归一化. 后一个条件主要作用为简化计算, 因为应用此条件之后, 第 $0$ 修正项与其他各阶修正项之间彼此正交. 若必要也可在计算最后将这个系数除掉以取得原始结果.\n将归一化条件代回式 \\eqref{1-2} 中并左乘 $\\psi_n^{(0)*}$再积分, 有\n$$\r\\int \\psi_n^{(0)*}\\psi_nd\\tau=\\langle \\psi_n^{(0)}|\\psi_n\\rangle=\\langle \\psi_n^{(0)}|\\psi_n^{(0)}\\rangle+\\lambda\\langle \\psi_n^{(0)}|\\psi_n^{(1)}\\rangle+\\ldots+\\lambda^k\\langle \\psi_n^{(0)}|\\psi_n^{(k)}\\rangle,\r$$因为 $\\lambda$ 不一定为 $0$, 应用归一化条件可得 $$\\langle \\psi_n^{(0)}|\\psi_n^{(1)}\\rangle=\\langle \\psi_n^{(0)}|\\psi_n^{(2)}\\rangle=\\ldots=\\langle \\psi_n^{(0)}|\\psi_n^{(k)}\\rangle=0.$$将式 \\eqref{1-2} 和 \\eqref{1-3} 代入 $Schr\\ddot odinger$ 方程 \\eqref{1-1} 中, 有\n$$\r(\\hat H^0+\\lambda\\hat H')(\\psi_n^{(0)}+\\lambda\\psi_n^{(1)}+\\lambda^2\\psi_n^{(2)}+\\ldots+\\lambda^k\\psi_n^{(k)})=(E_n^{(0)}+\\lambda E_n^{(1)}+\\lambda^2 E_n^{(2)}+\\ldots+\\lambda^k E_n^{(k)})(\\psi_n^{(0)}+\\lambda\\psi_n^{(1)}+\\lambda^2\\psi_n^{(2)}+\\ldots+\\lambda^k\\psi_n^{(k)})\r$$合并相同次数的 $\\lambda$, 有\n$$\r\\begin{equation}\r(\\hat H^0\\psi_n^{(0)})+\\lambda(\\hat H' \\psi_n^{(0)}+\\hat H^0\\psi_n^{(1)})+\\lambda^2(\\hat H' \\psi_n^{(1)}+\\hat H^0\\psi_n^{(2)})+\\ldots=E_n^{(0)}\\psi_n^{(0)}+\\lambda(E_n^{(1)}\\psi_n^{(0)}+E_n^{(0)}\\psi_n^{(1)})+\\lambda^2(E_n^{(2)}\\psi_n^{(0)}+E_n^{(1)}\\psi_n^{(1)}+E_n^{(0)}\\psi_n^{(2)})+\\ldots.\\label{1-4}\r\\end{equation}\r$$因为 $\\lambda$ 不一定为 $0$, 要使上式成立, 必须使 $\\lambda$ 的系数依次相等.\n对 $\\lambda^0$, 式 \\eqref{1-4} 退化为 $Schr\\ddot odinger$ 方程 $\\hat H^0\\psi_n^{(0)}=E_n^{(0)}\\psi_n^{(0)}$.\n一阶修正\r#\r对 $\\lambda^1$, 有\n$$\r\\begin{equation}\r\\hat H' \\psi_n^{(0)}+\\hat H^0\\psi_n^{(1)}=E_n^{(1)}\\psi_n^{(0)}+E_n^{(0)}\\psi_n^{(1)}.\\label{1-5}\r\\end{equation}\r$$对式 \\eqref{1-5} 两边同时左乘 $\\psi_m^{(0)*}$ 再积分, 有\n$$\r\\begin{equation}\r\\langle \\psi_m^{(0)}|\\hat H'|\\psi_n^{(0)}\\rangle+\\langle \\psi_m^{(0)}|\\hat H^0|\\psi_n^{(1)}\\rangle=E_n^{(1)}\\langle \\psi_m^{(0)}|\\psi_n^{(0)}\\rangle+E_n^{(0)}\\langle \\psi_m^{(0)}|\\psi_n^{(1)}\\rangle.\\label{1-6}\r\\end{equation}\r$$因为 $\\hat H^0$ 是 $Hermitian$ 算符, 满足\n$$\r\\langle \\psi_m^{(0)}|\\hat H^0|\\psi_n^{(1)}\\rangle=\\langle \\psi_n^{(1)}|\\hat H^0|\\psi_m^{(0)}\\rangle^*=E_m^{(0)}\\langle \\psi_n^{(1)}|\\psi_m^{(0)}\\rangle^*=E_m^{(0)}\\langle \\psi_m^{(0)}|\\psi_n^{(1)}\\rangle.\r$$代回式 \\eqref{1-6} 并稍加化简, 有\n$$\r\\begin{equation}\r(E_m^{(0)}-E_n^{(0)})\\langle \\psi_m^{(0)}|\\psi_n^{(1)}\\rangle=E_n^{(1)}\\delta_{nm}-\\langle \\psi_m^{(0)}|\\hat H'|\\psi_n^{(0)}\\rangle.\\label{1-7}\r\\end{equation}\r$$当 $m=n$ 时, $E_n^{(1)}$变为 $\\hat H'$的均值\n$$\r\\langle \\psi_n^{(0)}|\\hat H'|\\psi_n^{(0)}\\rangle=E_n^{(1)}=\\int \\psi_n^{(0)*}\\hat H'\\psi_n^{(0)}d\\tau.\r$$此时可以得到能量 $E_n$ 的一阶修正\n$$\rE_n\\approx E_n^{(0)}+E_n^{(1)}=E_n^{(0)}+\\int \\psi_n^{(0)*}\\hat H'\\psi_n^{(0)}d\\tau.\r$$对于波函数的一阶修正, 将$\\psi_n^{(1)}$ 使用完备正交基 $\\psi_k^{(0)}$ 展开 $$\r\\begin{equation}\r\\psi_n^{(1)}=\\sum_k a_k\\psi_k^{(0)}.\\label{1-8}\r\\end{equation}\r$$ 两边同时乘 $\\psi_m^{(0)*}$ 并积分, 有 $$\r\\langle \\psi_m^{(0)}|\\psi_n^{(1)}\\rangle=\\sum_k a_k\\langle \\psi_m^{(0)}|\\psi_k^{(0)}\\rangle=\\sum_k\\delta_{mk}a_k.\r$$ 当 $m=k$ 时, $\\delta_{mk}a_k$ 才有值 $a_m$. 此时上式变为 $$\r\\langle \\psi_m^{(0)}|\\psi_n^{(1)}\\rangle=a_m.\r$$ 因此可以将式 \\eqref{1-8} 转为更习惯的记法 $$\r\\begin{equation}\r\\psi_n^{(1)}=\\sum_m a_m\\psi_m^{(0)}, \\text{ 其中 } a_m= \\langle \\psi_m^{(0)}|\\psi_n^{(1)}\\rangle.\\label{1-9}\r\\end{equation}\r$$ 将式 \\eqref{1-9} 中的 $a_m$ 代回式 \\eqref{1-7}, 且假设 $n\\neq m $, 此时 $\\delta_{nm}=0$ $$\r(E_m^{(0)}-E_n^{(0)})a_m=\\langle \\psi_m^{(0)}|\\hat H'|\\psi_n^{(0)}\\rangle\r$$ 那么 $a_m$ 也可表示为 $$\ra_m=\\frac{\\langle \\psi_m^{(0)}|\\hat H'|\\psi_n^{(0)}\\rangle}{(E_m^{(0)}-E_n^{(0)})}.\r$$ 将新的 $a_m$ 代回式 \\eqref{1-9} $$\r\\psi_n^{(1)}=\\sum_m \\frac{\\langle \\psi_m^{(0)}|\\hat H'|\\psi_n^{(0)}\\rangle}{(E_m^{(0)}-E_n^{(0)})}\\psi_m^{(0)}, n\\neq m.\r$$ 而如果当 $n=m$, 式 \\eqref{1-9} 中的 $a_m$则变为 $$\ra_m= \\langle \\psi_m^{(0)}|\\psi_n^{(1)}\\rangle=\\langle \\psi_m^{(0)}|\\psi_m^{(1)}\\rangle.\r$$ 根据间接归一化条件, 有 $\\langle \\psi_m^{(0)}|\\psi_m^{(1)}\\rangle=0$. 所以对于 $\\psi_n^{(1)}$ 则无需考虑 $n=m$ 项.\n综上, 当 $\\lambda=1$ 时 $\\psi_n$ 可以记为 $$\r\\psi_n\\approx\\psi_n^{(0)}+\\sum_{n\\neq m} \\frac{\\langle \\psi_m^{(0)}|\\hat H'|\\psi_n^{(0)}\\rangle}{(E_m^{(0)}-E_n^{(0)})}\\psi_m^{(0)}.\r$$","date":"2025 年 11 月 19 日","externalUrl":null,"permalink":"/posts/perturbation_theory/","section":"","summary":"","title":"微扰理论(编辑中)","type":"posts"},{"content":"","date":"2025 年 11 月 18 日","externalUrl":null,"permalink":"/tags/gromacs/","section":"Tags","summary":"","title":"Gromacs","type":"tags"},{"content":"rmsd 是通过分析轨迹中结构与参照结构位置偏移量的均方根, 以判断轨迹中构象是否稳定的参数.\n而 mdrun 生成的 md.xtc 轨迹与参照的初始结构 md.tpr 并未进行 PBC 的处理, 假定盒子的 x 轴为 0-16, 因此靠近右侧边界的分子会有一部分原子的 x 坐标为 1 左右.\n如果直接使用\n1 gmx rms -s md.tpr -f md.xtc -o rmsd.xvg -tu ps 进行 RMSD 分析, 会得到一个这样的图像. 这样的结果显然是有问题的. 因为在变化的过程中原子可能会穿越边界, x 坐标从接近 16 突变为 1 左右, 而参考结构中该原子的坐标为接近 16 的数值, 此时的 RMSD 图像会有一个突变的过程.\n如果使用\n1 gmx trjconv -s md.tpr -f md.xtc -o md_noPBC.xtc -pbc mol 对轨迹进行处理, 再使用\n1 gmx rms -s md.tpr -f md_noPBC.xtc -o rmsd_noPBC_mol.xvg -tu ps 生成 rmsd 图像如下 其中蓝色的线表示原始的 RMSD, 红色的线表示处理 PBC 之后的轨迹的 RMSD.\n此时的问题在于 RMSD 的初始值不是 0. 原因在于作为参照的初始结构并未进行 pbc 处理, 即参照结构的右侧分子的部分原子在盒子左侧, 但轨迹中的该原子被修正到了盒子右侧之外.\n使用\n1 gmx trjconv -s md.tpr -f md_noPBC1.xtc -o reference_noPBC1.gro -b 0 -e 0 获取轨迹中第 0 帧作为参照, 得到图像 现在 RMSD 的起点变为 0 了. 但过程中依旧存在突变, 因为使用-pbc mol修正周期性后, 若分子的质心跨过盒子边界, 依然会出现在盒子另一侧.\n如果使用-pbc nojump参数, 能够保证聚合物不会出现跨越盒子边界的情况, 使用上述方法可以得到图像 在最后得到了很好的收敛.\n然而分析轨迹发现, 使用-pbc nojump得到的轨迹是初始在某一盒子内的 6 条聚合物的相互作用, 并不能反映除了稳定构象以外的其他东西.\n结论是, 判断是否达到平衡可以使用-pbc mol参数得到的轨迹对比第一帧的结构进行判断, 而对于氢键, 能量等数据似乎还是需要使用-pbc mol参数, 在特定盒子内进行研究.\n","date":"2025 年 11 月 18 日","externalUrl":null,"permalink":"/posts/trjconv_and_rmsd/","section":"","summary":"","title":"trjconv中pbc参数对RMSD的影响","type":"posts"},{"content":"","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]